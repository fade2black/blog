{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my Perosnal Blog","text":"<p>This blog is a space where I share my journey with the Rust programming language. Here, you\u2019ll find my thoughts, experiments, and results as I explore Rust, cryptography, distributed systems, and cloud computing world. I\u2019ll also share useful code snippets and tips that I\u2019ve learned along the way. </p> <p>Find me on LinkedIn and Github.</p>"},{"location":"#all-articles","title":"All Articles","text":""},{"location":"#secure-communication-with-kyber-and-dilithium-in-rust","title":"Secure Communication with Kyber and Dilithium in Rust","text":"<p> What Is Post-Quantum Cryptography? Quantum computers are no longer just science fiction\u2014they\u2019re getting real. And with them comes a big challenge: they could break many of the cryptographic systems we rely on today to keep our data safe. Most current encryption methods, like RSA or Elliptic Curve Cryptography,... </p> 21 Jul 2025"},{"location":"#implementing-distributed-cron-jobs-with-etcd","title":"Implementing Distributed Cron Jobs with etcd","text":"<p> In this article I\u2019ll walk you through a project I built using Rust that acts as a distributed cron scheduler. This project allows users to add, list, and remove cron jobs via a set of RESTful endpoints. The system continuously monitors the current time, ensuring that scheduled tasks ... </p> 16 Feb 2025"},{"location":"#building-leader-election-in-distributed-systems-with-etcd","title":"Building Leader Election in Distributed Systems with etcd","text":"<p> In distributed systems, leader election is a critical process that ensures coordination and consistency across multiple nodes. One way to implement leader election is through the use of a reliable key-value store, such as etcd. In this article, I'll explore how to implement a simple leader election implementation in Rust using an etcd server. ... </p> 07 Feb 2025"},{"location":"#building-a-simple-functional-language-compiler","title":"Building a Simple Functional Language Compiler","text":"<p> A simple compiler for a toy functional language written in Rust, supporting functions, conditionals, and arithmetic with 32-bit floats. It converts source code into WebAssembly Text (.wat) and binary (.wasm) using hand-written lexer, parser, AST, and code generator. This project explores compiler design, Rust programming, and WebAssembly generation in an educational setting... </p> 03 Apr 2022"},{"location":"dcron/","title":"Distributed Cron","text":"16 feb 2025"},{"location":"dcron/#implementing-distributed-cron-jobs-with-etcd","title":"Implementing Distributed Cron Jobs with etcd","text":""},{"location":"dcron/#introduction","title":"Introduction","text":"<p>In this article I\u2019ll walk you through a project I built using Rust that acts as a distributed cron scheduler. This project allows users to add, list, and remove cron jobs via a set of RESTful endpoints. The system continuously monitors the current time, ensuring that scheduled tasks are executed at the right moment. The advantage of being distributed is the increased availability of the service. If one node goes down, other nodes can continue processing requests and monitoring jobs.</p>"},{"location":"dcron/#the-inner-workings","title":"The Inner Workings","text":"<pre><code>flowchart\n    n1[\"etcd\"] &lt;--&gt; n2[\"Monitor\"] &amp; n3[\"http server\"]\n    n4[user] --&gt; n3[\"http server\"]\n    n1@{ shape: cyl}</code></pre> <p>The distributed cron starts by spawning a thread monitoring current time and http server for processing RESTful requests.</p> <pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    tracing_subscriber::fmt::init();\n\n    let result = tokio::try_join!(daemon::monitor(), run_http_server());\n\n    if let Err(err) = result {\n        error!(\"{err}\");\n    }\n\n    info!(\"Terminating...\");\n\n    Ok(())\n}\n</code></pre> <p>For processing endpoint requests, I\u2019ve used the Tokio Axum server. Cron jobs are stored in an etcd server as key-value pairs. When a new <code>add job</code> request is received, the application parses the submitted cron expression and command to execute. It then generates a unique key string and creates a JSON object with three fields to store in etcd: <code>pattern</code>, <code>next</code>, and <code>command</code>.</p> <ul> <li><code>Pattern</code>: holds the cron expression.</li> <li><code>Next</code>: stores the next scheduled execution time (the upcoming time when the command should run).</li> <li><code>Command</code>: holds the command that will be executed.</li> </ul> <p>This structure ensures that all cron jobs are stored consistently, and the use of the etcd server enables mutual access and synchronisation across multiple nodes.</p> <pre><code>async fn store_cron_job(json_str: &amp;str) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let mut client = Client::new().await?;\n\n    let lock_key = client.lock().await?;\n    let key = generate_unique_key(\"cron\");\n    client.store_cron_job(&amp;key, json_str).await?;\n    client.unlock(&amp;lock_key).await?;\n\n    Ok(())\n}\n</code></pre> <p>where <code>json_str</code> looks, for example, like</p> <pre><code>{\n  \"pattern\": \"* * * * *\",\n  \"next\": \"2025-02-16 14:14:00 +01:00\",\n  \"command\": \"echo hello, world\"\n}\n</code></pre> <p>When the server starts, it spawns a separate thread that periodically checks the current time. This thread locks access to the cron jobs, reads all the jobs from etcd, and processes them one by one. For each job, it checks the \"next\" occurrence time. If the scheduled time is less than the current time, the server spawns a separate child process to run the job\u2019s command, then updates the job's \"next\" occurrence time accordingly. After processing, the server sleeps for 3 seconds before repeating the process. </p> <pre><code>pub async fn monitor() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let mut client = Client::new().await?;\n\n    loop {\n        let lock_key = client.lock().await?;\n        let kvs = client.get_cron_jobs().await?;\n\n        for kv in kvs {\n            process(&amp;mut client, &amp;kv.0, &amp;kv.1).await?;\n        }\n        client.unlock(&amp;lock_key).await?;\n\n        time::sleep(time::Duration::from_secs(SLEEP_TIME)).await;\n    }\n}\n</code></pre> <p>The role of etcd in this application is to provide exclusive access to the cron jobs by offering a distributed locking mechanism. This is crucial because only one node should run a particular job at any given time. Both the monitoring thread and the HTTP actions that manipulate cron jobs stored in etcd lock a mutex before entering the critical section. Once the task is completed, the mutex is unlocked. For example,</p> <pre><code>pub async fn delete(key: &amp;str) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let mut client = Client::new().await?;\n\n    let lock_key = client.lock().await?;\n    client.delete_cron_job(key).await?;\n    client.unlock(&amp;lock_key).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"dcron/#usage","title":"Usage","text":"<p>The easiest way to run the app is to build it and execute it locally. Assuming etcd is running locally, for example start three separate processes to emulate three different nodes. Be sure to set a unique port for each Axum server process and specify the <code>ETCD_URL</code> environment variable to match the etcd server URL.</p> <pre><code>export ETCD_URL=http:://1.2.3.4:1234\n./dcron\n</code></pre> <p>Another option is to create a Kubernetes deployment with three replicas of the server, along with a service that exposes a single IP address for interacting with the dcron server.</p>"},{"location":"dcron/#conclusion","title":"Conclusion","text":"<p>While this simple project is by no means a replacement for established frameworks like Kubernetes' CronJob, it served as an exploration of Rust's asynchronous features and the functionality of the etcd server. By building this distributed cron scheduler, I gained valuable hands-on experience with these tools and saw how they can be leveraged in real-world applications. The full source code is available on GitHub</p>"},{"location":"kyber-dilithium/","title":"Kyber-Dilithium","text":"21 jul 2025"},{"location":"kyber-dilithium/#secure-communication-with-kyber-and-dilithium-in-rust","title":"Secure Communication with Kyber and Dilithium in Rust","text":""},{"location":"kyber-dilithium/#what-is-post-quantum-cryptography","title":"What Is Post-Quantum Cryptography?","text":"<p>Quantum computers are no longer just science fiction\u2014they\u2019re getting real. And with them comes a big challenge: they could break many of the cryptographic systems we rely on today to keep our data safe.</p> <p>Most current encryption methods, like RSA or Elliptic Curve Cryptography, depend on math problems that are tough for regular (classical) computers to solve. But quantum computers could solve those same problems much faster using special algorithms like Shor\u2019s algorithm. That means the encrypted data we think is secure today might not be safe in the future.</p> <p>That\u2019s where post-quantum cryptography (PQC) comes in. It\u2019s a new kind of cryptography designed to resist attacks even from quantum computers. Instead of relying on things like factoring or discrete logarithms, PQC algorithms use different mathematical problems, like lattice-based constructions, that are believed to be hard for both classical and quantum computers to crack.</p> <p>Organizations like NIST (the National Institute of Standards and Technology) have been working on standardizing these new algorithms. Two of the most promising ones are Kyber (used for exchanging keys securely) and Dilithium (used for digital signatures). These are the tools I'll be using in my demo.</p> <p>It\u2019s also worth noting that NIST has selected an additional algorithm called Hamming Quasi-Cyclic (HQC) as a backup to Module-Lattice based Key Encapsulation Mechanism (ML-KEM) a.k.a Kyber, the primary choice for general-purpose encryption. HQC is based on different mathematical foundations, giving us more options if future research reveals weaknesses in lattice-based methods.</p>"},{"location":"kyber-dilithium/#digital-signatures-and-key-encapsulation-mechanisms-kems","title":"Digital Signatures and Key Encapsulation Mechanisms (KEMs)","text":"<p>Before I jump into my demo, it\u2019s good to understand two key building blocks: digital signatures and key encapsulation mechanisms (KEMs).</p> <p>A digital signature lets someone prove that a message (or data) really came from them and hasn\u2019t been tampered with. Think of it like signing a document\u2014except it's done with math. In my demo, the server uses the Dilithium signature scheme to sign its public key, so the client can verify it's talking to the right party and not an imposter.</p> <p>A key encapsulation mechanism (KEM) is a way for two parties to securely agree on a shared secret over an insecure network. One side publishes a public key, and the other uses it to generate a shared key and send it back in a \u201ccapsule\u201d (ciphertext). The owner of the private key can open the capsule and recover the same shared key. In my case, I use Kyber, a lattice-based KEM, to establish this shared secret.</p> <p>Now, you might be wondering: how is KEM different from regular public-key encryption?</p> <p>The main difference is that public-key encryption is typically used to encrypt arbitrary messages, while KEM is specifically designed to securely exchange secret keys. It\u2019s a streamlined, more efficient approach for key exchange\u2014especially useful when you want to switch to fast symmetric encryption (like AES) afterward, which is exactly what I do.</p>"},{"location":"kyber-dilithium/#communication-flow-using-kyber-dilithium","title":"Communication Flow Using Kyber + Dilithium","text":"<p>To show how post-quantum cryptography can be used in a real-world setting, I\u2019ve created a simple Rust demo that simulates a secure communication session between a client and a server.</p> <p>For the sake of the example, I pre-generated a Dilithium key pair and stored it in the project directory:</p> <ul> <li><code>keys/dil_pk.txt</code>: the public key (accessible to anyone)</li> <li><code>keys/dil_sk.txt</code>: the secret key (only accessible by the server)</li> </ul> <p>Let\u2019s walk through the communication process.</p> <p>Roles:</p> <ul> <li>Client </li> <li>Server</li> </ul>"},{"location":"kyber-dilithium/#step-1","title":"Step 1","text":"<p>Client initiates communication.</p> <ul> <li>Client sends communication request (e.g. opens a TCP connection to the Server)</li> <li>This is just the initial network setup \u2014 no cryptography yet.</li> </ul>"},{"location":"kyber-dilithium/#step-2","title":"Step 2","text":"<p>Server sends its Kyber public key + Dilithium signature. Server </p> <ul> <li>already has a pair of digital signature (dilithium) keys: <code>(pk_dil, sk_dil)</code></li> <li>generates a pair of Kyber keys: <code>(pk_kyber, sk_kyber)</code></li> <li>signs its Kyber public key using its Dilithium secret key: <code>signature = sign(pk_kyber, sk_dil)</code></li> <li>sends the following payload to the client </li> </ul> <pre><code>{\n    \"pk_kyber\": \"...\",\n    \"signature\": \"...\"\n}\n</code></pre>"},{"location":"kyber-dilithium/#step-3","title":"Step 3","text":"<p>Client verifies the signature. Client</p> <ul> <li>already has Server's Dilithium public key (<code>pk_dil</code>) through some trusted method (e.g., certificate, config, or manual distribution)</li> <li>verifies: <code>verify(pk_kyber, signature, pk_dil)</code></li> <li>if the client is unable to verify the signature then terminates the connection (because the client can\u2019t trust that the key is really from the server), otherwise the client trusts the server.</li> <li>generates and secret key and encapsulates it using Server's Kyber public key: <code>(ciphertext, shared_secret) = encapsulate(pk_kyber, rng)</code></li> <li>sends the <code>ciphertext</code> to the Server.</li> </ul>"},{"location":"kyber-dilithium/#step-4","title":"Step 4","text":"<p>Server decapsulates the ciphertext. Server receives the ciphertext and uses its Kyber secret key to recover the shared secret: <code>shared_secret = decapsulate(ciphertext, sk_kyber)</code></p> <p>Now both Client and Server share the same secret.</p>"},{"location":"kyber-dilithium/#step-5","title":"Step 5","text":"<p>Secure symmetric communication begins. </p> <p>With the shared secret established, Server and Client switch to symmetric encryption (like AES-GCM) for fast, secure communication.</p>"},{"location":"kyber-dilithium/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    autonumber\n    Note left of Server: Server has (pk_dil, sk_dil)\n    Client-&gt;&gt;Server: Initial request\n    Server--&gt;&gt;Server: Generate [pk_kyber, sk_kyber]\n    Server--&gt;&gt;Server: signature = sign(pk_kyber, sk_dil)\n    Server-&gt;&gt;Client: [pk_kyber, signature]\n\n    Note right of Client: Client tries to verify the signature.\n    Client--&gt;&gt;Client: verify(pk_kyber, signature, pk_dil)\n    Client--&gt;&gt;Client: if unable to verify stop here, &lt;br&gt; can\u2019t trust.\n    Client--&gt;&gt;Client: Generate a secret key and encapsulate it &lt;br&gt; [ciphertext, shared_secret] = encapsulate(pk_kyber, rng)\n    Client-&gt;&gt;Server: ciphertext\n    Server--&gt;&gt;Server: shared_secret = decapsulate(ciphertext, sk_kyber)\n    Note over Server, Client: Client and Server share the same secret.</code></pre>"},{"location":"kyber-dilithium/#demo-secure-communication-in-rust-using-kyber-dilithium-aes-gcm","title":"Demo: Secure Communication in Rust Using Kyber + Dilithium + AES-GCM","text":"<p>The full example is available in my GitHub repository, but here\u2019s the core part of the demo (the <code>main.rs</code> file) which ties everything together.</p> <p>This simple Rust program demonstrates:</p> <ul> <li>how a client and server establish a shared secret using Kyber</li> <li>how the server proves its identity using Dilithium signatures</li> <li>and how both parties securely communicate using AES-GCM symmetric encryption</li> </ul> <pre><code>use kyber_playground::Server;\nuse kyber_playground::Client;\n\nfn main() {   \n    let mut client = Client::new(); \n    let client_messages = [\"Hi!\", \"What's up!\", \"Me also good!\"];\n    let mut server =  Server::new();\n    let server_messages = [\"Hi!\", \"All good! You?\", \"Glad to hear from you!\"];\n\n    // Client initiates a communication.\n    // Server accepts the connection and generates a (kyber public key, signature of the public key) pair. \n    let (pk, sig) = server.generate_pk_and_sig();\n\n    // Server sends the public key and signature to the client over a network.\n    // Client recieves the payload, verifies the public key, generates\n    // a secret key, encapsulates it, and sends it back to the server.\n    let ciphertext = client.accept_pk_and_sig(pk, sig);\n    // Server recieves the ciphertext and decapsulates it.\n    server.accept_ciphertext(ciphertext);\n    // At this stage both client and server have a shared secert key\n    // and now can securely communicate using one of secert key algorithms.\n    // e.g. AES-GCM\n    // Server and client start to communicate.\n    for i in 0..3 {\n        let plaintext = client_messages[i].as_bytes();\n        let (nonce, ciphertext) = client.encrypt_message(plaintext);\n        // Client sends the nonce and ciphertext over netwwork to the server \n        let decrypted = server.decrypt_message(&amp;ciphertext, nonce);\n        println!(\"Client: {:?}\", String::from_utf8(decrypted).unwrap());\n\n        let plaintext = server_messages[i].as_bytes();\n        let (nonce, ciphertext) = server.encrypt_message(plaintext);\n         // Server replies with the nonce and ciphertext over netwwork to the client\n        let decrypted = client.decrypt_message(&amp;ciphertext, nonce);\n        println!(\"Server: {:?}\", String::from_utf8(decrypted).unwrap());\n    }                \n}\n</code></pre> <p>This example demonstrates just the high-level flow. If you\u2019re curious about the implementation details\u2014like how keys are loaded from files, how Kyber and Dilithium are integrated, or how AES-GCM is used under the hood\u2014feel free to explore the full source code on GitHub.</p> <p>In the next part, I\u2019m planning to expand the demo into a more realistic setup, with separate client and server processes communicating over a network using the TCP protocol. This version will include key exchange and secure message transmission using symmetric encryption (AES-GCM) in a real network environment.</p>"},{"location":"leader-election/","title":"Leader Election","text":"16 feb 2025"},{"location":"leader-election/#building-leader-election-in-distributed-systems-with-etcd","title":"Building Leader Election in Distributed Systems with etcd","text":""},{"location":"leader-election/#introduction","title":"Introduction","text":"<p>In distributed systems, leader election is a critical process that ensures coordination and consistency across multiple nodes. One way to implement leader election is through the use of a reliable key-value store, such as etcd. In this article, I'll explore how to implement a simple leader election implementation in Rust using an etcd server. Briefly, the 'leader election' problem in a distributed system addresses the coordination challenge among multiple nodes. The goal is to elect a leader node that makes decisions on behalf of all nodes in a cluster, avoiding conflicts, race conditions, and inconsistencies. Etcd is a distributed key-value store providing a reliable way to store data across a cluster of nodes (machines), ensuring consistency and availability. Besides the basic CRUD operations on key-value pairs, etcd provdes other crucial components such lease and distributed shared lock. In simple terms, a lease is a mechanism used to manage the lifetime of a key-value pair in the etcd key-value store. You can create a lease with a specific Time-To-Live (TTL) and then associate it with a key. When the lease\u2019s TTL expires, the key is automatically deleted. Similarly, distributed lock is used to coordinate access to a shared resource in a distributed system, ensuring that only one node can hold the lock at a time. These features, when combined, form the core of a leader election service. Version 3 of etcd introduces a leader election provides along with the corresponding methods.</p>"},{"location":"leader-election/#implementation","title":"Implementation","text":"<p>The solution is based on a lease acquisition and renewal mechanism. When a node starts, it spawns a separate task that creates a lease and then calls the campaign method with the lease ID as a parameter. If multiple nodes are competing to be elected as the leader, only one node is selected, while the others are blocked by the campaign method. The blocked nodes remain in this state until the current leader either relinquishes leadership or fails, e.g., due to network partitioning at which point the lease expires. Once the lease expires, the blocked nodes are awakened and will retry to acquire leadership. Once a node acquires leadership, it maintains its status by periodically sending keep-alive requests to the etcd server to renew the lease. This ensures that the lease doesn't expire while the other nodes remain blocked and wait for the next leader election phase.</p> <p><pre><code>async fn participate_in_election(args: &amp;Args) -&gt; Result&lt;(), Error&gt; {\n    let mut client = connect(args).await?;\n\n    loop {\n        let resp = client.lease_grant(TTL, None).await?;\n        let lease_id = resp.id();\n\n        info!(\"Starting a new campaign.\");\n        let resp = client\n            .campaign(ELECTION_NAME, args.node.clone(), lease_id)\n            .await?;\n        let leader_key = resp\n            .leader()\n            .ok_or(Error::ElectError(\"Failed to retrieve the leader.\".into()))?;\n        info!(\"\ud83e\udd73 I am the leader ({})\", args.node);\n\n        if let Ok((mut keeper, _)) = client.lease_keep_alive(lease_id).await {\n            loop {\n                info!(\"\u23f0 Keeping alive the lease {}...\", leader_key.key_str()?);\n                keeper.keep_alive().await?;\n                time::sleep(Duration::from_secs(7)).await;\n            }\n        } else {\n            error!(\"Failed to keep lease alive. Re-campaigning.\");\n        }\n    }\n}\n</code></pre> At the same time, nodes observe election proclamations in order, as made by the elected leaders, to stay aware of the current leader.</p> <pre><code>async fn observe_election(args: &amp;Args, state: Arc&lt;RwLock&lt;State&gt;&gt;) -&gt; Result&lt;(), Error&gt; {\n    let mut client = connect(args).await?;\n\n    let mut msg = client.observe(ELECTION_NAME).await?;\n    loop {\n        if let Some(resp) = msg.message().await? {\n            let kv = resp\n                .kv()\n                .ok_or(Error::WatchError(\"Unable to retrieve key/value\".into()))?;\n            let key = kv.key_str()?;\n            let val = kv.value_str()?;\n\n            let mut st = state.write().await;\n            (*st).is_leader = val == args.node;\n            info!(\n                \"\ud83d\udfe2 Current leader is {val} with key {key}, node.is_leader={}\",\n                (*st).is_leader\n            );\n        }\n    }\n}\n</code></pre> <p>You can find the full implementation here</p> <p>To launch the entire process for three nodes, you can start each node in a separate console window as follows</p> <pre><code>% node --node node1 --host 127.0.0.1 --port 50686\n</code></pre> <pre><code>% node --node node2 --host 127.0.0.1 --port 50686\n</code></pre> <pre><code>% node --node node3 --host 127.0.0.1 --port 50686\n</code></pre> <p>where the <code>host</code> and <code>port</code> refer to the URL and port number of the etcd server used to interact with the etcd cluster.</p>"},{"location":"leader-election/#conclusion","title":"Conclusion","text":"<p>eader election is a critical component in distributed systems, ensuring high availability and fault tolerance. The implementation discussed here serves as a starting point, but to build a production-ready leader election system, it\u2019s important to consider additional nuances specific to your use case. For example, factors like network partitioning, node failure handling, and consistency guarantees should be carefully addressed. For a deeper dive into best practices, AWS provides insights and best-practice recommendations. You can find the full implementation here.</p>"},{"location":"mini-lang/","title":"Functional Language Compiler","text":"03 apr 2022"},{"location":"mini-lang/#building-a-simple-functional-language-compiler-in-rust","title":"Building a Simple Functional Language Compiler in Rust","text":""},{"location":"mini-lang/#introduction","title":"Introduction","text":"<p>For fun and learning, I built a compiler for a small toy functional (Turing complete \ud83d\ude09) language in Rust. The language is minimal: it supports defining functions, conditionals, and basic arithmetic. To keep things simple, all values are 32-bit floating point numbers, and every expression ends with a semicolon.</p> <p>The compiler takes source code written in this language and converts it into WebAssembly, producing both WebAssembly Text (<code>.wat</code>) and binary (<code>.wasm</code>) files. Everything is hand-written\u2014from the lexer and parser to the abstract syntax tree and code generator.</p> <p>Language Overview</p> <ul> <li>Functions: define reusable blocks of code</li> <li>Conditionals: <code>if-then-else</code> expressions</li> <li>Arithmetic : addition, subtraction, multiplication, division</li> <li>Comments: lines starting with symbol \"#\"</li> <li>Types: all 32-bit floats</li> </ul> <p>Example 1: computing the sum of the first n integers. <pre><code># Sum of first `n` integers\ndef sum(x) \n if x == 1 \n   then 1\n   else sum(x-1) + x;\n</code></pre></p> <p>Example 2: Solving a quadratic equation <pre><code># Solution of a second\n# order equation with coeffients a,b,c\n\ndef root1(a b c)\n  if discr(a, b, c) &lt; 0\n  then 0 \n  else (-b + sqrt(discr(a, b, c)))/(2*a);\n\ndef root2(a b c)\n  if discr(a, b, c) &lt; 0\n  then 0 \n  else (-b - sqrt(discr(a, b, c)))/(2*a);\n</code></pre></p>"},{"location":"mini-lang/#formal-definition","title":"Formal Definition","text":"<ul> <li>Keywords: <code>def</code>, <code>if</code>, <code>then</code>, <code>else</code></li> <li>Identifiers: <code>[a-zA-Z][a-zA-Z0-9]*</code></li> <li>Numbers: decimal floating-point values <code>[0-9]?(.?[0-9])</code></li> <li>Expressions: arithmetic operations, comparisons, function calls, and conditional expressions</li> </ul> <p>The Context Free Grammar (CFG) for the language is defined as follows:</p> <p><pre><code>Program ::= def Prototype Expression ; | def Prototype Expression ; Program\n\nPrototype ::= Identifier(Params) | Identifier()\n\nParams ::= Identifier Params | Identifier\n\nExpression ::= Exp | IfExp\n\nExp ::= SubExp | Exp &lt; SubExp | Exp &gt; SubExp | Exp &lt;&gt; SubExp | Exp == SubExp\n\nSubExp ::= Term | SubExp + Term | SubExp - Term | SubExp | Term\n\nTerm ::= Factor | Term * Factor | Term / Factor | Term &amp; Factor\n\nFactor ::= -Exp | ( Exp ) | Identifier | Number | FuncionCall\n\nFuncionCall ::= Identifier(Args) | Identifier()\n\nArgs ::= Exp | Comma Args\n\nIfExp ::= if Exp then Exp else Exp\n</code></pre> The compiler follows a straightforward pipeline:  the lexer tokenizes the input, the parser builds an AST, and the code generator emits WebAssembly code.</p>"},{"location":"mini-lang/#implementation","title":"Implementation","text":""},{"location":"mini-lang/#lexer-aka-scanner","title":"Lexer (a.k.a. Scanner)","text":"<p>The lexer is the first stage of the compiler, responsible for converting raw source code  into a sequence of tokens that the parser can understand.  In this project, the lexer is implemented as a generic <code>Lexer&lt;T&gt;</code> struct that reads from any input implementing  <code>std::io::Read</code>, allowing it to handle files, strings, or other streams.</p> <p>Internally, the lexer keeps track of the current character,  the current lexeme (the string being built),  and the line number for error reporting.  It reads characters using a UTF-8 reader to handle all valid characters safely.</p> <p>The lexer handles several types of tokens:</p> <ul> <li>Whitespace: skipped automatically, with line numbers incremented whenever a newline is encountered.</li> <li>Comments: lines starting with # are skipped until the end of the line.</li> <li>Identifiers: sequences of letters and digits, starting with a letter. These typically correspond to function names or variable names in the language.</li> <li>Numbers: sequences of digits, optionally containing a decimal point. Only 32-bit floating-point numbers are supported.</li> <li>Operators and punctuation: such as <code>+</code>, <code>-</code>, <code>*</code>,... (see <code>src/lexer.rs</code> for more)</li> </ul> <p>The lexer uses helper functions to organize the logic:</p> <ul> <li><code>get_char()</code> reads the next character from the input.</li> <li><code>skip_whitespace()</code> ignores spaces, tabs, and newlines.</li> <li><code>skip_comment()</code> ignores all characters until the end of a line.</li> <li><code>get_identifier()</code> and <code>get_number()</code> build identifiers and numeric literals, respectively, adding characters to the lexeme string.</li> <li><code>other()</code> handles operators and punctuation, including multi-character tokens like <code>&lt;&gt;</code> (not equal) and <code>==</code> (equal).</li> </ul> <p>By the end of this stage, the source code has been transformed into a stream  of well-defined tokens that the parser can use to construct the abstract syntax tree.  The lexer is entirely hand-written, giving full control over how tokens are recognized and providing a clear foundation for learning compiler design in Rust.  You can find the source code here.</p>"},{"location":"mini-lang/#parser","title":"Parser","text":"<p>The parser transforms the stream of tokens from the lexer into an Abstract Syntax Tree (AST), representing the structure of the program. It is implemented as a hand-written recursive-descent parser (for LL(1) grammars), following a standard operator-precedence hierarchy:</p> <p><code>factors</code> &gt; <code>terms</code> &gt; <code>subexpressions</code> &gt; <code>expressions</code></p> <p>This ensures that multiplication and division bind tighter than addition/subtraction, and comparison operators are evaluated at the top level.</p> <p>The parser handles:</p> <ul> <li>Function definitions, including name, parameters, and body expressions</li> <li>Expressions, including arithmetic, variable references, function calls, and conditional <code>if-then-else</code> expressions</li> <li>Error logging, using an <code>ErrorLogger</code> that records parsing errors with line numbers</li> <li>Error recovery, via a synchronization mechanism that skips tokens until a logical resumption point (<code>;</code> or <code>end-of-file</code>)</li> </ul> <p>A key component is the <code>main_loop()</code>, which drives parsing by repeatedly reading function definitions until the end of the source.  The parser also distinguishes between variable references and function calls in <code>parse_identifier_expr()</code>, correctly collecting arguments when present.</p> <p>Overall, the parser converts the source code into a structured, navigable AST, providing a solid foundation for generating WebAssembly code. Most other parsing functions are straightforward and follow standard recursive-descent patterns, so only the main loop, expression hierarchy, and argument handling require special attention. You can find the source code here.</p>"},{"location":"mini-lang/#ast-and-code-generation","title":"AST and Code Generation","text":"<p>The parser produces an Abstract Syntax Tree (AST) that represents the structure of the program independently of the source syntax.  In this compiler, the AST is intentionally minimal and expression-oriented, closely mirroring the language design where everything evaluates to a value.</p>"},{"location":"mini-lang/#ast-design","title":"AST Design","text":"<p>Expressions are represented by the ExprNode enum. Each variant corresponds to a core language construct:  numeric literals, variables, unary and binary expressions, function calls, and conditional expressions.  Recursive structures are modeled using <code>Box&lt;ExprNode&gt;</code>,  allowing complex expressions such as nested arithmetic or conditionals to be represented naturally.</p> <p>Rather than separating analysis and code generation into multiple passes, each AST node knows how to emit its own WebAssembly Text (WAT)  representation via the <code>to_wat()</code> method.  This keeps the implementation compact and makes the mapping between  language constructs and WebAssembly instructions explicit.</p> <p>Some notable design choices:</p> <ul> <li>Expression-oriented code generation: each expression emits instructions that leave its result on the WebAssembly stack.</li> <li>Operator-driven emission: binary and unary expressions delegate instruction selection to the Operator type, keeping operator semantics centralized.</li> <li>Conditionals map directly to Webassembly\u2019s structured control  flow using <code>if (result f32)</code>, <code>else</code>, and <code>end</code>.</li> </ul> <p>Function calls are handled uniformly, with a small exception for built-in functions such as <code>sqrt</code> or <code>abs</code>. These are mapped directly to WebAssembly instructions instead of emitted as function calls, avoiding unnecessary indirection.</p>"},{"location":"mini-lang/#functions-and-prototypes","title":"Functions and Prototypes","text":"<p>Functions are represented by a <code>Prototype</code> (name and parameters) and a body expression. The prototype is responsible for emitting the function signature, while the body emits the instructions computing the return value. All functions return a single <code>f32</code>, matching the language\u2019s simplified type system.</p> <p>This design closely follows the idea that a function is simply a named expression with parameters.</p>"},{"location":"mini-lang/#code-generator","title":"Code Generator","text":"<p>The <code>CodeGenerator</code> is responsible for assembling the final WebAssembly module.  It iterates over the AST, emits function definitions, and exports all defined functions so they can be called from JavaScript or other WebAssembly hosts.</p> <p>The generation process is straightforward:</p> <ol> <li>Open a WebAssembly module.</li> <li>Emit each function definition by delegating to the AST.</li> <li>Export all function symbols.</li> <li>Close the module.</li> </ol> <p>By keeping code generation mostly inside the AST nodes,  the CodeGenerator remains small and declarative,  acting as a coordinator rather than a complex transformation stage.</p>"},{"location":"mini-lang/#wrapping-up","title":"Wrapping Up","text":"<p>The modules described so far\u2014lexer, parser, AST,  and code generation\u2014cover the core of the compiler pipeline.  There are a few additional supporting modules in the repository  (such as error handling and operator definitions), but they follow naturally from the design already discussed and do not introduce new concepts.</p> <p>Rather than walking through every remaining file,  I prefer to leave those details to the reader.  The full source code is available on GitHub and is intentionally kept small and readable,  making it easy to explore individual modules independently.</p> <p>At this point, the interesting question becomes how all of these pieces are wired together and how the compiler is actually executed.  That logic lives in <code>main.rs</code>.</p>"},{"location":"mini-lang/#putting-everything-together-mainrs","title":"Putting Everything Together (<code>main.rs</code>)","text":"<pre><code>use minilang::code_generator::CodeGenerator;\nuse minilang::parser::Parser;\nuse std::process::Command;\n\nuse std::env;\nuse std::fs::File;\n\nfn main() -&gt; std::io::Result&lt;()&gt; {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    if args.len() &lt; 3 {\n        println!(\"Not enough arguments. Please specify input and output files names.\");\n        return Ok(());\n    }\n\n    let src = File::open(args[1].as_str())?;\n    let target = File::create(args[2].as_str())?;\n\n    let mut parser = Parser::new(src);\n    parser.main_loop();\n\n    let err_logger = parser.get_error_logger();\n\n    if err_logger.has_errors() {\n        for error in err_logger.iter() {\n            println!(\"SYNTAX ERROR: {}\", error);\n        }\n    } else {\n        // Generate WebAssembly text\n        CodeGenerator::new(parser.get_asts(), target).run()?;\n        // Generate binary WebAssembly\n        Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(format!(\"wat2wasm {}\", args[2].as_str()))\n            .output()\n            .expect(\"failed to execute 'wat2wasm'\");\n    }\n\n    Ok(())\n}\n</code></pre> <p>If <code>wat2wasm</code> is not available, you can install it using <code>brew install wabt</code>.</p> <p>Create a file named <code>fib.txt</code> with the following content:</p> <pre><code># Computes Fibbonaci sequence\ndef fib(x)\n  if (x == 1) | (x == 2)\n    then 1\n    else fib(x-1) + fib(x-2);\n</code></pre> <p>and the run <pre><code>cargo run fib.txt target.wat\n</code></pre> It'll generate two files, <code>target.wat</code> and <code>target.wasm</code>. Next create a javascript file <code>fib.js</code></p> <pre><code>const { readFileSync } = require(\"fs\");\n\nconst run = async () =&gt; {\n  const buffer = readFileSync(\"./target.wasm\");\n  const module = await WebAssembly.compile(buffer);\n  const instance = await WebAssembly.instantiate(module);\n  console.log(instance.exports.fib(5)); // Call fibbonaci function\n};\n\nrun();\n</code></pre> <p>and run it</p> <pre><code>node fib.js\n</code></pre> <p>The following example computes roots of a quadratic equation (assuming they are different from 0).</p> <pre><code># Computes factorial sequence\n# Solution of a second\n# order equation with coeffients a,b,c\n\ndef discr(a b c)\n  b*b - 4*a*c;\n\ndef root1(a b c)\n  if discr(a, b, c) &lt; 0\n  then 0\n  else (-b + sqrt(discr(a, b, c)))/(2*a);\n\ndef root2(a b c)\n  if discr(a, b, c) &lt; 0\n  then 0\n  else (-b - sqrt(discr(a, b, c)))/(2*a);\n</code></pre>"},{"location":"mini-lang/#conclusion","title":"Conclusion","text":"<p>This project was an exercise in building a compiler from first principles, deliberately avoiding frameworks  or generator tools in favor of handwritten components. By keeping the language small and the type system uniform, the focus stays on the essential pipeline: lexing, parsing, AST construction, and code generation.  Targeting WebAssembly made the output both concrete and inspectable, allowing each design decision to be traced directly to emitted WAT and wasm instructions. While the compiler is intentionally minimal, it provides a complete, end-to-end implementation that can serve as a foundation for experimentation, extension, or simply a deeper understanding of how compilers work under the hood. The full source code is available on GitHub</p>"},{"location":"noise-protocol/","title":"Noise Protocol Framework","text":""},{"location":"noise-protocol/#noise-token-breakdown","title":"Noise Token Breakdown","text":"<p>Each token corresponds to an action that the HandshakeState machine needs to perform. These actions mainly involve key generation, key exchange, key mixing, and data encryption.</p>"},{"location":"noise-protocol/#1-e-ephemeral-key-sendreceive","title":"1. <code>e</code> \u2014 Ephemeral Key (send/receive)","text":"<ul> <li>Definition: <code>e</code> refers to an ephemeral key pair. It's a temporary, one-time key generated by each party for this handshake.</li> <li>Purpose: It helps provide forward secrecy \u2014 even if your long-term static key gets compromised, the ephemeral key ensures previous sessions are still secure.</li> <li> <p>Action:</p> </li> <li> <p>Send: You generate a new ephemeral keypair and send its public key.</p> </li> <li>Receive: You accept the remote ephemeral public key (and later use it in a DH operation).</li> </ul> <p>Example: When you see the token <code>e</code> in the handshake pattern, the initiator is sending an ephemeral public key (their <code>e</code>).</p>"},{"location":"noise-protocol/#2-s-static-key-sendreceive","title":"2. <code>s</code> \u2014 Static Key (send/receive)","text":"<ul> <li>Definition: <code>s</code> refers to a static key pair, usually long-term (could be your identity).</li> <li>Purpose: This key is used for authentication and is often used to identify each party.</li> <li> <p>Action:</p> </li> <li> <p>Send: You send your static public key encrypted (if the pattern uses encryption).</p> </li> <li>Receive: You accept the remote static public key and may use it for authentication or further DH operations.</li> </ul> <p>Example: When you see the token <code>s</code>, it means the initiator is sending its static key encrypted (in some patterns). The responder may use it to authenticate the initiator's identity.</p>"},{"location":"noise-protocol/#3-ee-diffie-hellman-ephemeral-ephemeral","title":"3. <code>ee</code> \u2014 Diffie-Hellman (ephemeral-ephemeral)","text":"<ul> <li>Definition: <code>ee</code> means performing a Diffie-Hellman (DH) exchange between the ephemeral keys of both parties.</li> <li>Purpose: The result of this DH operation is a shared secret, which is then mixed into the chaining key (ck).</li> <li> <p>Action:</p> </li> <li> <p>You do a DH operation between your ephemeral private key and the remote party\u2019s ephemeral public key.</p> </li> <li>This produces a shared secret, which is then mixed with your existing state (e.g., the handshake hash <code>h</code>).</li> </ul> <p>Example: When you see <code>ee</code>, the initiator and responder are computing <code>DH(e_i, e_r)</code> where <code>e_i</code> and <code>e_r</code> are their respective ephemeral keys.</p>"},{"location":"noise-protocol/#4-es-diffie-hellman-ephemeral-static","title":"4. <code>es</code> \u2014 Diffie-Hellman (ephemeral-static)","text":"<ul> <li>Definition: <code>es</code> means performing a Diffie-Hellman (DH) exchange between the ephemeral private key and the static public key of the other party.</li> <li>Purpose: This helps to mix both the ephemeral and static keys into the handshake state.</li> <li> <p>Action:</p> </li> <li> <p>You perform DH between your ephemeral private key and the remote static public key.</p> </li> <li>This mixed secret helps derive the final session keys and secures the handshake.</li> </ul> <p>Example: When you see <code>es</code>, the initiator and responder do <code>DH(e_i, s_r)</code> where <code>e_i</code> is the initiator's ephemeral key and <code>s_r</code> is the responder's static key.</p>"},{"location":"noise-protocol/#5-se-diffie-hellman-static-ephemeral","title":"5. <code>se</code> \u2014 Diffie-Hellman (static-ephemeral)","text":"<ul> <li>Definition: <code>se</code> means performing a Diffie-Hellman (DH) exchange between the static private key and the ephemeral public key of the other party.</li> <li>Purpose: Similar to <code>es</code>, it allows the static keys to be securely mixed into the handshake, ensuring both parties\u2019 identities are authenticated.</li> <li> <p>Action:</p> </li> <li> <p>You do DH between your static private key and the remote ephemeral public key.</p> </li> <li>This operation produces a shared secret mixed into the handshake state.</li> </ul> <p>Example: When you see <code>se</code>, the initiator and responder do <code>DH(s_i, e_r)</code> where <code>s_i</code> is the initiator's static key and <code>e_r</code> is the responder's ephemeral key.</p>"},{"location":"noise-protocol/#6-ss-diffie-hellman-static-static","title":"6. <code>ss</code> \u2014 Diffie-Hellman (static-static)","text":"<ul> <li>Definition: <code>ss</code> refers to performing a Diffie-Hellman (DH) exchange between the static keys of both parties.</li> <li>Purpose: This provides the final authentication of both parties\u2019 identities and allows them to mutually verify each other.</li> <li> <p>Action:</p> </li> <li> <p>You perform DH between your static private key and the remote static public key.</p> </li> <li>This is typically the final operation in the handshake.</li> </ul> <p>Example: When you see <code>ss</code>, the initiator and responder do <code>DH(s_i, s_r)</code> where <code>s_i</code> and <code>s_r</code> are their respective static keys.</p>"},{"location":"noise-protocol/#7-psk-pre-shared-key","title":"7. <code>psk</code> \u2014 Pre-Shared Key","text":"<ul> <li>Definition: <code>psk</code> refers to a Pre-Shared Key, which is a symmetric key that both parties know ahead of time (not generated during the handshake).</li> <li>Purpose: It strengthens the handshake and provides additional protection against certain attacks, like MITM.</li> <li> <p>Action:</p> </li> <li> <p>The PSK is mixed into the handshake at various stages (e.g., <code>psk0</code>, <code>psk1</code>).</p> </li> <li>This means both parties contribute the PSK into their derived secret(s) for better security.</li> </ul> <p>Example: When you see <code>psk</code>, it means the protocol is mixing in a pre-shared key for added security at specific points (like after the first message or after DH operations).</p>"},{"location":"noise-protocol/#summary-of-each-tokens-role","title":"Summary of Each Token's Role","text":"Token Meaning Action/Operation e Ephemeral key (send/receive) Generate &amp; exchange ephemeral public key s Static key (send/receive) Send/receive static key (authenticates identity) ee DH (ephemeral-ephemeral) Perform DH between two ephemeral keys es DH (ephemeral-static) Perform DH between ephemeral private and static public key se DH (static-ephemeral) Perform DH between static private and ephemeral public key ss DH (static-static) Perform DH between two static keys (final verification) psk Pre-shared key Mix a shared symmetric key into the handshake for extra security"},{"location":"noise-protocol/#example-1-nn","title":"Example 1 (<code>NN</code>)","text":"<p>Given the handshake pattern: <pre><code>-&gt; e\n&lt;- e, ee\n</code></pre> Here\u2019s what happens</p> <p><code>-&gt; e</code></p> <ol> <li>Initiator generates an ephemeral keypair <code>(e_i.private, e_i.public)</code>.</li> <li>Initiator sends <code>[e_i.public]</code></li> <li>Responder receives <code>[e_i.public]</code>. The responder stores the initiator\u2019s ephemeral public key for later use.</li> </ol> <p><code>&lt;- e, ee</code></p> <ol> <li>The responder generates its own ephemeral keypair <code>(e_r.private, e_r.public)</code>.</li> <li>Responder performs <code>shared_secret = DH(e_r.private, e_i.public)</code> and the shared secret is mixed into the internal handshake state to derive symmetric keys.</li> <li>Responder sends <code>[e_r.public]</code></li> </ol>"},{"location":"noise-protocol/#example-2-xx","title":"Example 2 (<code>XX</code>)","text":"<pre><code>-&gt; e\n&lt;- e, ee, s, es\n-&gt; s, se\n</code></pre> <p><code>-&gt; e</code></p> <ol> <li>The initiator generates an ephemeral keypair <code>(e_i.prv, e_i.pub)</code>.</li> <li>The initiator sends <code>[e_i.pub]</code>.</li> <li>Responder receives <code>[e_i.pub]</code>. The responder stores the initiator\u2019s ephemeral public key for later use.</li> </ol> <p><code>&lt;- e, ee, s, es</code></p> <ol> <li>The responder generates its own ephemeral keypair <code>(e_r.prv, e_r.pub)</code>.</li> <li>The responder performs <code>shared_secret = DH(e_r.prv, e_i.pub)</code> and the shared secret is mixed into the internal handshake state to derive symmetric keys <code>ck</code>.</li> <li>The responder performs <code>shared_secret = DH(s_r.prv, e_i.pub)</code> and the shared secret is mixed into the internal handshake state to derive symmetric keys <code>ck</code>.</li> <li>The responder sends <code>[e_r.pub, s_r.pub]</code>.</li> <li>The initiator recieves <code>[e_r.pub, s_r.pub]</code>.</li> </ol> <p><code>-&gt; s, se</code></p> <ol> <li>The initiator computes  <code>shared_secret = DH(s_i.prv, e_r.pub)</code> and the shared secret is mixed into the internal handshake state to derive symmetric keys <code>ck</code>.</li> <li>The initiator sends <code>[s_i.pub]</code>.</li> </ol> <p>The <code>XX</code> handshake pattern involves the following sequence:</p> <ol> <li>Initiator \u2192 e, s</li> <li>Responder \u2190 e, ee, s, es</li> <li>Initiator \u2192 s, se</li> </ol> <p>Here\u2019s what each token means and how the initiator and responder exchange messages.</p>"},{"location":"noise-protocol/#step-by-step-breakdown","title":"Step-by-Step Breakdown:","text":""},{"location":"noise-protocol/#1-initiator-e-s-message-1","title":"1. Initiator \u2192 e, s (Message 1)","text":"<ul> <li><code>e</code> (Ephemeral Key): The initiator generates a new ephemeral key pair (<code>e_i</code>) and sends the ephemeral public key (<code>e_i.public</code>) to the responder.</li> <li><code>s</code> (Static Key): The initiator also sends its static public key (<code>s_i.public</code>).</li> </ul> <p>Message 1 sent by the initiator:</p> <pre><code>Message 1 -&gt; [e_i.public | s_i.public]\n</code></pre> <ul> <li>Purpose of <code>e</code>: This ensures forward secrecy. The ephemeral key (<code>e_i</code>) will only be used for this session. If the initiator's static key (<code>s_i</code>) gets compromised in the future, this session is still secure due to the ephemeral key.</li> <li>Purpose of <code>s</code>: The static key (<code>s_i</code>) is sent to the responder for authentication, so the responder can verify who the initiator is.</li> </ul>"},{"location":"noise-protocol/#2-responder-e-ee-s-es-message-2","title":"2. Responder \u2190 e, ee, s, es (Message 2)","text":"<p>Upon receiving Message 1, the responder processes the incoming message.</p> <ul> <li><code>e</code> (Ephemeral Key): The responder receives the initiator\u2019s ephemeral public key (<code>e_i.public</code>), which they will use in the next Diffie-Hellman (DH) operation.</li> <li><code>ee</code> (Ephemeral-Ephemeral DH): The responder generates their own ephemeral key pair (<code>e_r</code>), and then performs a Diffie-Hellman operation between their ephemeral private key (<code>e_r</code>) and the initiator\u2019s ephemeral public key (<code>e_i.public</code>). This produces a shared secret, which is mixed into the handshake state (<code>ck</code>).</li> <li><code>s</code> (Static Key): The responder sends their static public key (<code>s_r.public</code>) to the initiator. This is used for authentication.</li> <li><code>es</code> (Ephemeral-Static DH): The responder performs a Diffie-Hellman operation between their ephemeral private key (<code>e_r</code>) and the initiator\u2019s static public key (<code>s_i.public</code>). This provides additional mixing of the shared secret into the state (<code>ck</code>).</li> </ul> <p>Message 2 sent by the responder:</p> <pre><code>Message 2 &lt;- [e_r.public | encrypted(s_r.public) | e_r, s_r]\n</code></pre> <ul> <li>Purpose of <code>ee</code>: The ephemeral-ephemeral DH step ensures the responder contributes to the shared secret.</li> <li>Purpose of <code>s</code>: The static public key allows the initiator to authenticate the responder.</li> <li>Purpose of <code>es</code>: The ephemeral-static DH operation allows the responder\u2019s ephemeral key to be combined with the initiator\u2019s static key, adding additional entropy to the key exchange.</li> </ul>"},{"location":"noise-protocol/#3-initiator-s-se-message-3","title":"3. Initiator \u2192 s, se (Message 3)","text":"<p>The initiator now processes the responder\u2019s message and prepares the final message.</p> <ul> <li><code>s</code> (Static Key): The initiator receives the responder\u2019s static public key (<code>s_r.public</code>), which they will use for authentication.</li> <li><code>se</code> (Static-Ephemeral DH): The initiator performs Diffie-Hellman between their static private key (<code>s_i.private</code>) and the responder's ephemeral public key (<code>e_r.public</code>). This creates a shared secret that is mixed into the handshake state (<code>ck</code>).</li> </ul> <p>Message 3 sent by the initiator:</p> <pre><code>Message 3 -&gt; [encrypted(s_i.public) | e_r.public]\n</code></pre> <ul> <li>Purpose of <code>se</code>: This static-ephemeral DH operation provides another layer of authentication and key exchange, ensuring both sides can verify each other's identity and derive the final shared secret.</li> </ul>"},{"location":"noise-protocol/#summary-of-each-token","title":"Summary of Each Token","text":"Token Meaning Action e Ephemeral Key (send) Initiator generates a new ephemeral key pair and sends the ephemeral public key (<code>e_i.public</code>) to the responder. s Static Key (send) Initiator sends its static public key (<code>s_i.public</code>) to the responder for authentication. ee Ephemeral-Ephemeral Diffie-Hellman Responder generates their ephemeral key pair (<code>e_r</code>) and performs DH with initiator's ephemeral key (<code>e_i.public</code>) to derive a shared secret. s Static Key (send) Responder sends their static public key (<code>s_r.public</code>) to the initiator for authentication. es Ephemeral-Static Diffie-Hellman Responder performs DH with their ephemeral private key (<code>e_r.private</code>) and initiator\u2019s static public key (<code>s_i.public</code>). se Static-Ephemeral Diffie-Hellman Initiator performs DH between their static private key (<code>s_i.private</code>) and responder\u2019s ephemeral public key (<code>e_r.public</code>)."},{"location":"noise-protocol/#why-is-this-important","title":"Why is this important?","text":"<p>The <code>XX</code> handshake pattern combines:</p> <ul> <li>Ephemeral Diffie-Hellman (<code>e</code>, <code>ee</code>, <code>se</code>) to ensure forward secrecy and mutual key derivation.</li> <li>Static keys (<code>s</code>, <code>s</code>) for authentication.</li> </ul> <p>This ensures that both parties are able to securely derive a shared secret while also authenticating each other\u2019s identity.</p>"},{"location":"pq-protocol/","title":"Kyber + Dilithium AKE Protocol Specification","text":"<p>Status: Draft \u2014 Phase 1 (Specification only)</p>"},{"location":"pq-protocol/#1-roles","title":"1. Roles","text":"<ul> <li>Client \u2014 initiates handshake, derives session key.</li> <li>Server \u2014 responds, authenticates using Dilithium signature.</li> </ul>"},{"location":"pq-protocol/#2-cryptographic-primitives","title":"2. Cryptographic Primitives","text":"Purpose Algorithm Key Encapsulation (KEM) Kyber (ephemeral per session) Signatures Dilithium (long-term server key) Hash / Transcript SHA-256 Key Derivation HKDF-SHA256 AEAD (optional for Phase 2) ChaCha20-Poly1305 or AES-GCM"},{"location":"pq-protocol/#3-handshake-overview","title":"3. Handshake Overview","text":"<p>Goal: derive a shared session key <code>K</code> between client and server.</p> <p>Flow (2.5 round trips)</p> <pre><code>  sequenceDiagram\n    Client--&gt;&gt;Server: ClientHello\n    Server--&gt;&gt;Client: ServerHello\n    Client--&gt;&gt;Server: ClientKEM</code></pre>"},{"location":"pq-protocol/#31-clienthello","title":"3.1 ClientHello","text":"Field Length Notes <code>client_id_len</code> <code>u8</code> length of <code>client_id</code> <code>client_id</code> variable optional, UTF-8 <code>client_nonce</code> 32 bytes random <p>Rust struct: <pre><code>pub struct ClientHello {\n    pub client_id: Vec&lt;u8&gt;,       // max 255 bytes\n    pub client_nonce: [u8; 32],\n}\n</code></pre></p>"},{"location":"pq-protocol/#32-serverhello","title":"3.2 ServerHello","text":"Field Length Notes <code>server_id_len</code> <code>u8</code> length of <code>server_id</code> <code>server_id</code> variable UTF-8 <code>server_nonce</code> 32 bytes random <code>pk_kyber</code> \\~1184 bytes Kyber768 public key <code>sig_dilithium</code> \\~2701 bytes Dilithium2 signature <p>The server computes</p> <pre><code>sig = Sign(sk_dil, pk_kyber || client_nonce || server_nonce || server_id)\n</code></pre>"},{"location":"pq-protocol/#33-clientkem","title":"3.3 ClientKEM","text":"Field Length Notes <code>ciphertext</code> \\~1088 bytes Kyber768 ciphertext"},{"location":"pq-protocol/#4-transcript-binding","title":"4. Transcript Binding","text":"<ul> <li>Maintain a running SHA-256 hash of all handshake messages (in serialized order).</li> <li>Server signs <code>pk_kyber || client_nonce || server_nonce || server_id</code> to bind its ephemeral key to the session.</li> <li>After ClientKEM, both sides compute: <pre><code>transcript_hash = SHA256(ClientHello || ServerHello || ClientKEM)\nsession_key = HKDF-Expand(ss, transcript_hash || \"Kyber-Dilithium-AKE\")\n</code></pre></li> <li>Server zeroizes sk_kyber after decapsulation.</li> </ul>"},{"location":"pq-protocol/#5-encoding-rules","title":"5. Encoding Rules","text":"<ul> <li>Variable-length fields are prefixed with u8 length.</li> <li>Fixed-length fields are written raw.</li> <li>This gives a deterministic canonical encoding for hashing/signing.</li> </ul>"},{"location":"pq-protocol/#6-future-extensions-phase-2","title":"6. Future Extensions (Phase 2+)","text":"<ul> <li>Client authentication using Dilithium</li> <li>Session resumption via PSK</li> <li>AEAD-encrypted application channel using session_key</li> </ul>"},{"location":"pq-protocol/#7-error-handling-rules","title":"7. Error Handling Rules","text":"<p>We want to clearly define what should happen if something goes wrong during the handshake.</p> Error Type When it occurs Action / Outcome Malformed message Parsing fails (e.g., wrong length prefix, truncated data) Abort handshake, log error Invalid signature Dilithium signature verification fails Abort handshake, do not derive keys Decapsulation failure Kyber decapsulation fails (invalid ciphertext) Abort handshake, do not derive keys Replay detected <code>client_nonce</code> or <code>server_nonce</code> seen before in short-term cache Abort handshake Unexpected message Message arrives out of expected order Abort handshake, log warning Crypto library failure Any KEM/signing/hash function fails Abort handshake, log error <p>Notes:</p> <ul> <li>Always zeroize ephemeral secrets (<code>sk_kyber, ss</code>) immediately on abort.</li> <li>Log errors for debugging but never leak sensitive info (don\u2019t include secrets in logs).</li> <li>Clients may retry with a new <code>ClientHello</code> if appropriate.</li> </ul>"},{"location":"pq-protocol/#handshake-state-machine","title":"Handshake State Machine","text":"<p>We can represent the handshake as a finite state machine (FSM) with explicit states.</p>"},{"location":"pq-protocol/#client-fsm","title":"Client FSM","text":"Current State Event/Action Next State <code>Init</code> <code>send_client_hello()</code> <code>SentClientHello</code> <code>SentClientHello</code> <code>receive_server_hello()</code> + verify sig <code>ReceivedServerHello</code> <code>ReceivedServerHello</code> <code>send_client_kem_ciphertext()</code> <code>SentKemCiphertext</code> <code>SentKemCiphertext</code> <code>finalize()</code> (derive session keys) <code>Complete</code> any error (bad sig, malformed msg, etc.) <code>Failed</code> <pre><code>stateDiagram-v2\n    [*] --&gt; Init\n    Init --&gt; SentClientHello: send_client_hello()\n    SentClientHello --&gt; ReceivedServerHello: receive_server_hello() + verify\n    ReceivedServerHello --&gt; SentKemCiphertext: send_client_kem()\n    SentKemCiphertext --&gt; Complete: finalize()\n    [*] --&gt; Failed: error</code></pre>"},{"location":"pq-protocol/#server-fsm","title":"Server FSM","text":"Current State Event/Action Next State <code>Init</code> <code>receive_client_hello()</code> <code>ReceivedClientHello</code> <code>ReceivedClientHello</code> <code>send_server_hello()</code> <code>SentServerHello</code> <code>SentServerHello</code> <code>receive_client_kem_ciphertext()</code> (derive session keys) <code>Complete</code> any error (bad msg, malformed data, etc.) <code>Failed</code> <pre><code>stateDiagram-v2\n    [*] --&gt; Init\n    Init --&gt; ReceivedClientHello : receive_client_hello()\n    ReceivedClientHello --&gt; SentServerHello : send_server_hello()\n    SentServerHello --&gt; Complete : receive_client_kem_ciphertext()\n    [*] --&gt; Failed : error</code></pre>"},{"location":"pq-protocol/#handshake-interaction","title":"Handshake Interaction","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant Client\n    participant Server\n\n    Note over Client,Server: Setup\n    Client-&gt;&gt;Server: TCP connect\n    Server--&gt;&gt;Client: accept connection\n\n    Note over Client,Server: Handshake Step 1\n    Client-&gt;&gt;Server: send_client_hello()\n    Server-&gt;&gt;Server: receive_client_hello()\n    Server--&gt;&gt;Client: acknowledgment implicitly via next step\n\n    Note over Client,Server: Handshake Step 2\n    Server-&gt;&gt;Client: send_server_hello()\n    Client-&gt;&gt;Client: receive_server_hello() + verify signature with server public key\n\n    Note over Client,Server: Handshake Step 3\n    Client-&gt;&gt;Server: send_client_kem()\n    Server-&gt;&gt;Server: receive_client_kem() + derive shared secret\n\n    Note over Client,Server: Handshake Complete\n    Client-&gt;&gt;Client: finalize() + derive shared secret\n    Server-&gt;&gt;Server: handshake complete, session keys established</code></pre>"},{"location":"pq-protocol/#9-status","title":"9. Status","text":"<p>Roles:</p> <ul> <li>\u2705 Crypto primitives</li> <li>\u2705 Handshake flow</li> <li>\u2705 Message formats (Rust structs)</li> <li>\u2705 Transcript binding</li> <li>\u2705 Key derivation</li> <li>\u2705 Error Handling</li> <li>\u2705 State machine</li> </ul> <p>Next logical step (Phase 2) is library setup &amp; project skeleton:</p> <ul> <li>Rust crates + PQClean bindings</li> <li>kem.rs, sig.rs, kdf.rs</li> <li>Message serialization</li> <li>Minimal client + server skeleton implementing the FSM</li> </ul>"}]}